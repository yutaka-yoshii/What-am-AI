# 因果関係・抽象概念の構造
## 直感的に見やすく表す場合
```
(
	( #原因のリスト（複数）
		(v0, choice, v3),
		(v0, position, v1)
	),
	(v0, position, v2), #結果(単数)
	( #抽象概念
		(Any, v0),
		(@sameway, v3, (v1, v2)), 
	)
)
@sameway = ((up, @upper), (down, @lower))
@upper = ((p01, p00), (p02, p01), ... (p33, p32))
```
イメージはこの通り。ただ、これだと同じ内容でも表し方が複数あるため、一意に定まる形式にしたい。そこで実装は以下のようにする。

## 実際の実装
（同じ因果関係については一意に表現されるようにした）
```
(
	( #原因リスト（複数）
		(*, choice, *),
		(*, position, *)
	),
	(*, position, *), #結果(単数)
	( #抽象概念
		(
			Any,
			((0,0,0),(0,1,0),(1,0))
		),
		(
			@sameway,
			((0,0,2),),
			(((0,1,2),),((1,2),)),
		), 
	)
)
@sameway = ((up, @upper), (down, @lower))
@upper = ((p01, p00), (p02, p01), ... (p33, p32))
@lower = ((p00, p01), (p01, p02), ... (p32, p33))
```

# 様々な抽象化のパターン
まず、上記の例は、次の2つの信念を抽象化して作られる。
```
(
	((*, choice, up), (*, position, *)),
	(*, position, *),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
		(@upper,((0,1,2)),((1,2)))
	)
)
@upper = ((p01, p00), (p02, p01), ... (p33, p32))
```
```
(
	((*, choice, down), (*, position, *)),
	(*, position, *),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
		(@lower,((0,1,2),),((1,2),))
	)
)
@lower = ((p00, p01), (p01, p02), ... (p32, p33))
```


---

また、抽象概念を拡張するケースもある。
抽象概念と抽象概念を融合すべきパターンと、抽象概念に個別概念を加えて拡張すべきパターン。

どこから確認するのが効率的か？

【関係性概念、抽象同士】
【差異1, 抽象同士】
抽象概念の融合の場合は例えば以下のようなケース。
```
(
	((*, choice, up), (*, position, *)),
	(*, position, *),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
		(@upper0,((0,1,2),),((1,2),))
	)
)
@upper0 = ((p01, p00), (p02, p01)
```
```
(
	((*, choice, up), (*, position, *)),
	(*, position, *),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
		(@upper1,((0,1,2),),((1,2),))
	)
)
@upper1 = ((p03, p02), (p04, p03))
```
特徴：原因・結果は完全一致。変数も参照先は完全一致。変数のうちの1つだけ、抽象概念が異なる。

---
【
【差異1?、抽象と直接】

抽象概念と直接概念の場合は以下のようなケース。
```
(
	((*, choice, up), (*, position, *)),
	(*, position, *),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
		(@upper0,((0,1,2),),((1,2),))
	)
)
@upper0 = ((p01, p00), (p02, p01)
```
```
(
	((*, choice, up), (*, position, p04)),
	(*, position, p03),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
	)
)
```

---
```
(
	((*, choice, up), (*, position, p01)),
	(*, position, p00),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
	)
)
```
```
(
	((*, choice, up), (*, position, p04)),
	(*, position, p04),
	(
		(Any,((0,0,0),(0,1,0),(1,0))),
	)
)
```
---
```
(
	((ai1, choice, up), (ai1, position, p01)),
	(ai1, position, p00),
)
```
```
(
	((ai2, choice, up), (ai2, position, p01)),
	(ai2, position, p00),
)
```
---
```
(
	((@ai, choice, up), (@ai, position, p01)),
	(@ai, position, p00),
	(
		(@ai, ((0,0,0),(0,1,0),(1,0))),
	)
)
@ai = ((ai1,),(ai2,))
```
```
(
	((ai3, choice, up), (ai3, position, p01)),
	(ai3, position, p00),
)
```
---
```
(
	((@ai12, choice, up), (@ai12, position, p01)),
	(@ai12, position, p00),
	(
		(@ai12, ((0,0,0),(0,1,0),(1,0))),
	)
)
@ai12 = ((ai1,),(ai2,))
```
```
(
	((@ai34, choice, up), (@ai34, position, p01)),
	(@ai34, position, p00),
	(
		(@ai34, ((0,0,0),(0,1,0),(1,0))),
	)
)
@ai34 = ((ai3,),(ai4,))
```

# 方向性の検討メモ
## 大まかな方針
抽象概念の修正を行う際に、その抽象概念を参照している因果関係全てについて逐一修正していくのは効率的ではない。イメージとしては、例えば ai5 isa @ai と定義すればそれで済むようにしたい。
そのため、概念は因果関係に埋め込むのではなく、あくまでも概念への参照を保持し、概念は柔軟に変化できるようにしておく。pythonでの実装上、参照か埋め込みかは区別されないため、何らかの工夫を行う。
また、無闇に概念を修正してしまうと信念体系全体を崩してしまうことにも注意が必要。例えば一つの事例のみで判断すると、全体に対しては信念体系の改悪となってしまう可能性があるため、概念の修正は何か慎重に行うための仕組みが必要。

## 実装の方向性
* まず、抽象概念については別途抽象概念のリストを作成し、そこで通し番号を管理する。概念の削除により歯抜けになったりするので、新規概念は空いている通し番号を再利用する場合もある。そのため、クラス化してその辺りの処理は外から気にしなくていいようにする。
* そのクラスの中で、各抽象概念について、変更の検討などのステータスを管理する。
* 総論としては、概念の変更前と変更後とで、よりシンプルに世界を説明できる方を是とするようにしたい。
* 一方、概念には「定義」と言えるような、「そもそもの由来」を示す因果関係があっても良い(その方が自然な)気がする。
* どちらを取るべきだろうか？
* 科学においては、概念の拠り所となる定義自体が更新されるということはよく起きる。しかしそれでも、定義は一意に定まっている。
* 一方日常においては、それほど定義が明確ではないことも多い。
* 抽象概念のコアイメージは、ずっと固定ではなく、世界認識の深化とともに変化していると思われる。
* これと同じように実装を考える。

→その抽象概念を直近で頻繁に参照してきている因果関係に基づいて、抽象概念の修正について検証するものとする。具体的には、

また、抽象概念の拡張が採用された場合、新規因果関係は不要になるが、どのようにその処理を行うか？（オッカムの剃刀の実装）

また、概念の縮小方向での修正をどうするか？
